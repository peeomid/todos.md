/**
 * Autocomplete logic for search mode in the TUI.
 * Provides inline suggestions for filter keys and values.
 */

import type { Task } from '../schema/index.js';

export interface AutocompleteSuggestion {
  type: 'key' | 'value';
  text: string; // Full completion text (e.g., "bucket:" or "today")
  display: string; // Display text (e.g., "bucket:" or "today")
  description?: string; // Optional help text
  preview?: string; // Short preview for values (e.g., "Today's tasks")
}

export interface AutocompleteContext {
  currentToken: string; // The token being typed (e.g., "bu" or "tod")
  filterKey: string | null; // If typing value, which key (e.g., "bucket")
  cursorInToken: number; // Cursor position within current token
  isAfterColon: boolean; // True if cursor is right after "key:"
}

export interface AutocompleteState {
  active: boolean; // Whether autocomplete is showing
  suggestions: AutocompleteSuggestion[];
  selectedIndex: number; // For arrow key navigation
  context: AutocompleteContext | null;
}

/**
 * Filter metadata registry with descriptions
 */
export const FILTER_SPECS = {
  status: {
    values: ['open', 'done', 'all'],
    description: 'Task completion status',
    valuePreviews: {
      open: 'Incomplete tasks',
      done: 'Completed tasks',
      all: 'All tasks',
    },
  },
  bucket: {
    values: ['now', 'today', 'upcoming', 'anytime', 'someday'],
    description: 'Planning bucket',
    valuePreviews: {
      now: 'Working on right now',
      today: "Today's focus",
      upcoming: 'Next up',
      anytime: 'Flexible timing',
      someday: 'Future ideas',
    },
  },
  energy: {
    values: ['high', 'normal', 'low'],
    description: 'Energy level required',
    valuePreviews: {
      high: 'High energy',
      normal: 'Normal energy',
      low: 'Low energy',
    },
  },
  priority: {
    values: ['high', 'normal', 'low'],
    description: 'Priority level',
    valuePreviews: {
      high: 'High priority',
      normal: 'Normal priority',
      low: 'Low priority',
    },
  },
  project: { values: 'dynamic' as const, description: 'Project ID' },
  area: { values: 'dynamic' as const, description: 'Area name' },
  due: {
    values: 'date' as const,
    description: 'Due date (YYYY-MM-DD, today, tomorrow)',
  },
  plan: {
    values: 'date' as const,
    description: 'Planned date (YYYY-MM-DD, today, tomorrow)',
  },
  tags: { values: 'dynamic' as const, description: 'Tag name' },
  parent: { values: 'dynamic' as const, description: 'Parent task ID' },
  'top-level': { values: ['true'], description: 'Show only top-level tasks' },
  overdue: { values: ['true'], description: 'Show only overdue tasks' },
  text: { values: 'freeform' as const, description: 'Full-text search' },
} as const;

export const METADATA_SPECS = {
  id: { values: 'freeform' as const, description: 'Local task id (within a project)' },
  created: { values: 'date' as const, description: 'Created date (YYYY-MM-DD, today, tomorrow)' },
  est: { values: 'freeform' as const, description: 'Estimate (e.g. 15m, 1h, 2h)' },
  bucket: FILTER_SPECS.bucket,
  energy: FILTER_SPECS.energy,
  priority: FILTER_SPECS.priority,
  project: FILTER_SPECS.project,
  area: FILTER_SPECS.area,
  tags: FILTER_SPECS.tags,
  parent: FILTER_SPECS.parent,
  plan: FILTER_SPECS.plan,
  due: FILTER_SPECS.due,
} as const;

export const ADD_METADATA_SPECS = {
  // Add-flow metadata intentionally excludes: id/created/project/parent
  // - `id` and `created` are generated by the tool
  // - `project` is chosen via the Project field
  // - `parent` is implied by indentation (subtasks)
  est: METADATA_SPECS.est,
  bucket: METADATA_SPECS.bucket,
  energy: METADATA_SPECS.energy,
  priority: METADATA_SPECS.priority,
  area: METADATA_SPECS.area,
  tags: METADATA_SPECS.tags,
  plan: METADATA_SPECS.plan,
  due: METADATA_SPECS.due,
} as const;

type SpecRegistry = Record<
  string,
  {
    values: readonly string[] | 'dynamic' | 'date' | 'freeform';
    description: string;
    valuePreviews?: Record<string, string>;
  }
>;

/**
 * Analyze current input and cursor position to determine autocomplete context
 */
export function getAutocompleteContext(
  input: string,
  cursorPos: number
): AutocompleteContext {
  // Handle empty input
  if (!input || cursorPos === 0) {
    return {
      currentToken: '',
      filterKey: null,
      cursorInToken: 0,
      isAfterColon: false,
    };
  }

  // Find the token at cursor position
  // Split by spaces but keep track of positions
  const tokens: Array<{ text: string; start: number; end: number }> = [];
  let currentStart = 0;

  input.split(/\s+/).forEach((token) => {
    if (token.length > 0) {
      const start = input.indexOf(token, currentStart);
      tokens.push({
        text: token,
        start,
        end: start + token.length,
      });
      currentStart = start + token.length;
    }
  });

  // Find which token contains the cursor
  let currentToken = '';
  let tokenStart = input.length;

  for (const token of tokens) {
    if (cursorPos >= token.start && cursorPos <= token.end) {
      currentToken = token.text;
      tokenStart = token.start;
      break;
    }
  }

  // If cursor is after all tokens (trailing space), treat as empty token
  if (currentToken === '' && cursorPos >= input.length) {
    return {
      currentToken: '',
      filterKey: null,
      cursorInToken: 0,
      isAfterColon: false,
    };
  }

  // Detect if this is a filter key or value
  const colonIndex = currentToken.indexOf(':');

  if (colonIndex === -1) {
    // Typing a filter key (or free text)
    return {
      currentToken,
      filterKey: null,
      cursorInToken: cursorPos - tokenStart,
      isAfterColon: false,
    };
  } else {
    // Typing a filter value
    const key = currentToken.slice(0, colonIndex);
    const value = currentToken.slice(colonIndex + 1);

    return {
      currentToken: value,
      filterKey: key,
      cursorInToken: cursorPos - tokenStart - colonIndex - 1,
      isAfterColon: value.length === 0,
    };
  }
}

/**
 * Generate suggestions based on context
 */
export function generateSuggestions(
  context: AutocompleteContext,
  allTasks: Task[]
): AutocompleteSuggestion[] {
  return generateSuggestionsWithSpecs(context, allTasks, FILTER_SPECS as unknown as SpecRegistry);
}

export function generateSuggestionsWithSpecs(
  context: AutocompleteContext,
  allTasks: Task[],
  specs: SpecRegistry
): AutocompleteSuggestion[] {
  if (context.filterKey) {
    return getValueSuggestions(context.filterKey, context.currentToken, allTasks, specs);
  }
  return getKeySuggestions(context.currentToken, specs);
}

/**
 * Get filter key suggestions
 */
function getKeySuggestions(partial: string, specs: SpecRegistry): AutocompleteSuggestion[] {
  const filterKeys = Object.keys(specs);

  // Filter keys that start with partial (case-insensitive)
  // Show all keys if partial is empty
  const matches = filterKeys.filter((key) =>
    partial ? key.toLowerCase().startsWith(partial.toLowerCase()) : true
  );

  return matches.map((key) => ({
    type: 'key' as const,
    text: `${key}:`,
    display: `${key}:`,
    description: specs[key]?.description,
  }));
}

/**
 * Get value suggestions for a specific filter key
 */
function getValueSuggestions(
  filterKey: string,
  partial: string,
  allTasks: Task[],
  specs: SpecRegistry
): AutocompleteSuggestion[] {
  const spec = specs[filterKey];
  if (!spec) return [];

  if (Array.isArray(spec.values)) {
    // Static values (status, bucket, energy, priority)
    const matches = spec.values.filter((val) =>
      val.toLowerCase().startsWith(partial.toLowerCase())
    );
    return matches.map((val) => {
      const preview = spec.valuePreviews?.[val];
      return {
        type: 'value' as const,
        text: val,
        display: val,
        preview,
      };
    });
  }

  if (spec.values === 'dynamic') {
    // Dynamic values (project, area, tags) - extract from tasks
    return getDynamicValueSuggestions(filterKey, partial, allTasks);
  }

  if (spec.values === 'date') {
    // Date suggestions
    return getDateSuggestions(partial);
  }

  if (spec.values === 'freeform') {
    return [];
  }

  return [];
}

/**
 * Extract dynamic values from task index
 */
function getDynamicValueSuggestions(
  filterKey: string,
  partial: string,
  allTasks: Task[]
): AutocompleteSuggestion[] {
  const uniqueValues = new Set<string>();

  allTasks.forEach((task) => {
    let value: string | undefined;

    switch (filterKey) {
      case 'project':
        value = task.projectId;
        break;
      case 'area':
        value = task.area;
        break;
      case 'tags':
        task.tags?.forEach((tag) => uniqueValues.add(tag));
        return;
      case 'parent':
        value = task.parentId ?? undefined;
        break;
    }

    if (value) uniqueValues.add(value);
  });

  const matches = Array.from(uniqueValues).filter((val) =>
    val.toLowerCase().includes(partial.toLowerCase())
  );

  // Sort alphabetically and limit to 10 suggestions
  return matches
    .sort()
    .slice(0, 10)
    .map((val) => ({
      type: 'value' as const,
      text: val,
      display: val,
    }));
}

/**
 * Date suggestions
 */
function getDateSuggestions(partial: string): AutocompleteSuggestion[] {
  const suggestions: AutocompleteSuggestion[] = [
    { type: 'value', text: 'today', display: 'today' },
    { type: 'value', text: 'tomorrow', display: 'tomorrow' },
  ];

  // If they're typing a date, suggest format
  if (partial.match(/^\d/)) {
    suggestions.push({
      type: 'value',
      text: partial,
      display: `${partial} (YYYY-MM-DD)`,
    });
  }

  return suggestions.filter((s) => s.text.toLowerCase().startsWith(partial.toLowerCase()));
}

/**
 * Apply autocomplete suggestion to input string
 */
export function applySuggestion(
  input: string,
  cursorPos: number,
  suggestion: AutocompleteSuggestion,
  context: AutocompleteContext
): { newInput: string; newCursorPos: number } {
  // Split by spaces and find the token to replace
  const tokens: Array<{ text: string; start: number; end: number }> = [];
  let currentStart = 0;

  input.split(/\s+/).forEach((token) => {
    if (token.length > 0) {
      const start = input.indexOf(token, currentStart);
      tokens.push({
        text: token,
        start,
        end: start + token.length,
      });
      currentStart = start + token.length;
    }
  });

  // Find which token contains the cursor
  let tokenIndex = -1;
  let tokenToReplace: { text: string; start: number; end: number } | null = null;

  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    if (token && cursorPos >= token.start && cursorPos <= token.end) {
      tokenIndex = i;
      tokenToReplace = token;
      break;
    }
  }

  if (tokenIndex === -1 || !tokenToReplace) {
    // Cursor at end after trailing space, append suggestion
    const replacement =
      suggestion.type === 'value' && context.filterKey
        ? `${context.filterKey}:${suggestion.text}`
        : suggestion.text;
    const prefix = input.trimEnd();
    const sep = prefix ? ' ' : '';
    const suffix = suggestion.type === 'value' ? ' ' : '';
    const newInput = `${prefix}${sep}${replacement}${suffix}`;
    return { newInput, newCursorPos: newInput.length };
  }

  // Build replacement text
  const replacement =
    suggestion.type === 'value' && context.filterKey
      ? `${context.filterKey}:${suggestion.text}`
      : suggestion.text;

  // Reconstruct input with replacement
  const before = input.slice(0, tokenToReplace.start);
  const after = input.slice(tokenToReplace.end);
  const suffix = suggestion.type === 'value' ? ' ' : '';
  const newInput = before + replacement + suffix + after.trimStart();

  const newCursorPos = before.length + replacement.length + suffix.length;

  return { newInput, newCursorPos };
}
